<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Multi Scene Mix Shader Transition</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/dat.gui@0.7.9/build/dat.gui.min.js"></script>
<script>
  let renderer, camera;
  let scenes = [];
  let renderTargets = [];
  let carMeshes = [];
  let screenScene, screenCamera, screenQuad;
  let params;
  let lastTime = performance.now();

  init();
  animate();

  function init() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(w, h);
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 100);
    camera.position.set(0, 2, 6);

    // 创建多个场景
    const sceneCount = 3;
    for (let i = 0; i < sceneCount; i++) {
      const scene = new THREE.Scene();
      scene.background = new THREE.Color().setHSL(i / sceneCount, 0.4, 0.1);

      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5, 10, 5);
      scene.add(dir);

      // 地面
      const groundGeo = new THREE.PlaneGeometry(20, 20);
      const groundMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(i / sceneCount, 0.3, 0.3)
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // 车（方块）
      const carGeo = new THREE.BoxGeometry(1, 0.5, 2);
      const carMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(i / sceneCount, 0.7, 0.6),
        emissive: 0x000000
      });
      const car = new THREE.Mesh(carGeo, carMat);
      car.position.set(0, 0.25, 0);
      scene.add(car);

      // 场景里再加一点差异物体
      const extraGeo = new THREE.BoxGeometry(0.5, 1, 0.5);
      for (let j = 0; j < 5; j++) {
        const extraMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(i / sceneCount, 0.5, 0.5 + j * 0.05)
        });
        const extra = new THREE.Mesh(extraGeo, extraMat);
        extra.position.set(-4 + j * 2, 0.5, -3 - i * 2);
        scene.add(extra);
      }

      scenes.push(scene);
      carMeshes.push(car);

      const rt = new THREE.WebGLRenderTarget(
        w * window.devicePixelRatio,
        h * window.devicePixelRatio,
        { samples: 4 }
      );
      renderTargets.push(rt);
    }

    // 屏幕混合场景
    screenScene = new THREE.Scene();
    screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const quadGeo = new THREE.PlaneGeometry(2, 2);
    const quadMat = new THREE.ShaderMaterial({
      uniforms: {
        tSceneA: { value: null },
        tSceneB: { value: null },
        progress: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tSceneA;
        uniform sampler2D tSceneB;
        uniform float progress;
        varying vec2 vUv;

        void main() {
          vec4 colorA = texture2D(tSceneA, vUv);
          vec4 colorB = texture2D(tSceneB, vUv);

          // 从左到右划过
          float edge = smoothstep(progress - 0.02, progress + 0.02, vUv.x);
          vec4 mixed = mix(colorA, colorB, edge);

          gl_FragColor = mixed;
        }
      `,
      depthTest: false,
      depthWrite: false
    });

    screenQuad = new THREE.Mesh(quadGeo, quadMat);
    screenScene.add(screenQuad);

    // 控制参数
    params = {
      fromScene: 0,
      toScene: 1,
      progress: 0.0,
      autoPlay: false,
      speed: 0.5
    };

    const gui = new dat.GUI();
    gui.add(params, 'fromScene', 0, scenes.length - 1, 1).name('From Scene');
    gui.add(params, 'toScene', 0, scenes.length - 1, 1).name('To Scene');
    gui.add(params, 'progress', 0, 1, 0.001).name('Progress');
    gui.add(params, 'autoPlay').name('Auto Play');
    gui.add(params, 'speed', 0.1, 2, 0.1).name('Speed');

    window.addEventListener('resize', onWindowResize, false);
  }

  function onWindowResize() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();

    const dpr = window.devicePixelRatio;
    for (let i = 0; i < renderTargets.length; i++) {
      renderTargets[i].setSize(w * dpr, h * dpr);
    }
  }

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    updateLogic(dt);
    render();
  }

  function updateLogic(dt) {
    // 车和摄像机的统一运动
    const t = performance.now() * 0.001;

    const carZ = Math.sin(t) * 4.0;
    const carX = Math.cos(t * 0.5) * 2.0;

    for (let i = 0; i < carMeshes.length; i++) {
      const car = carMeshes[i];
      car.position.x = carX;
      car.position.z = carZ;
      car.rotation.y = Math.atan2(
        Math.cos(t * 0.5) * 2.0,
        Math.cos(t) * 4.0
      );
    }

    camera.position.x = carX + 4 * Math.sin(t * 0.3);
    camera.position.y = 2 + Math.sin(t * 0.5) * 0.5;
    camera.position.z = carZ + 6 * Math.cos(t * 0.3);
    camera.lookAt(carX, 0.5, carZ);

    if (params.autoPlay) {
      params.progress += dt * params.speed * 0.2;
      if (params.progress > 1.0) {
        params.progress = 0.0;
        params.fromScene = params.toScene;
        params.toScene = (params.toScene + 1) % scenes.length;
      }
    }
  }

  function render() {
    // 先把每个场景渲染到自己的 RenderTarget
    for (let i = 0; i < scenes.length; i++) {
      renderer.setRenderTarget(renderTargets[i]);
      renderer.clear();
      renderer.render(scenes[i], camera);
    }

    renderer.setRenderTarget(null);

    // 选择要混合的两个场景
    const fromIndex = THREE.MathUtils.clamp(params.fromScene, 0, scenes.length - 1);
    const toIndex = THREE.MathUtils.clamp(params.toScene, 0, scenes.length - 1);

    screenQuad.material.uniforms.tSceneA.value = renderTargets[fromIndex].texture;
    screenQuad.material.uniforms.tSceneB.value = renderTargets[toIndex].texture;
    screenQuad.material.uniforms.progress.value = params.progress;

    renderer.render(screenScene, screenCamera);
  }
</script>
</body>
</html>
