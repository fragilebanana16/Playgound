### 点光源衰减公式
$$
F_{att} = \frac{1.0}{K_c + K_l \cdot d + K_q \cdot d^2}
$$

### 一个向量如何判断是方向还是位置？（齐次坐标的规则）

- **位置向量 (point)**： 用 (x,y,z,1.0) 表示。
  - 当 w=1 时，矩阵中的平移部分会对它生效。
  - 这样才能正确地把点从一个坐标系变换到另一个坐标系。
- **方向向量 (vector)**： 用 (x,y,z,0.0)表示。
  - 当 w=0 时，矩阵中的平移部分不会影响它。
  - 因为方向只表示“指向”，没有具体位置，不应该被平移。

#### ⚙️ 为什么要这样区分

矩阵变换通常写成 4×4 的形式：

$$
\begin{pmatrix}
R & T \\
0 & 1
\end{pmatrix}
$$


其中 RR 是旋转/缩放，TT 是平移。

- 对位置向量 (x,y,z,1)：
$$
\begin{pmatrix} R & T \\ 0 & 1 \end{pmatrix}
\cdot
\begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}
=
R \cdot \begin{pmatrix} x \\ y \\ z \end{pmatrix} + T
$$
→ 平移生效。

- 对方向向量 (x,y,z,0)：
$$
\begin{pmatrix} R & T \\ 0 & 1 \end{pmatrix}
\cdot
\begin{pmatrix} x \\ y \\ z \\ 0 \end{pmatrix}
=
R \cdot \begin{pmatrix} x \\ y \\ z \end{pmatrix}
$$
→ 平移部分被消除，只剩旋转/缩放。

### 光照

#### 风氏光照模型(Phong Lighting Model)

风氏光照模型的主要结构由3个分量组成：

环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照

###### 漫反射(Diffuse)
漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度

漫反射公式
$$
I_{diffuse} = k_d \cdot I_l \cdot \max(0, \mathbf{N} \cdot \mathbf{L})
$$
- kd：材质的漫反射系数（通常就是物体颜色 objectColor） 
- 𝐼𝑙：光源颜色/强度（就是 lightColor）  
- 𝑁：单位化的表面法线向量 
- 𝐿：单位化的光照方向向量（光源位置 - 片元位置） 
- max (0 ,𝑁 ⋅ 𝐿 ) ：余弦定律，保证夹角大于 90° 时光照为 0
```c
vec3 norm = normalize(Normal);              // → 公式里的 N
vec3 lightDir = normalize(lightPos - FragPos); // → 公式里的 L

float diff = max(dot(norm, lightDir), 0.0); // → 公式里的 max(0, N·L)

vec3 diffuse = diff * lightColor * objectColor; 
// → k_d * I_l * max(0, N·L)
```
#### 镜面(Specular)光照

镜面光照也决定于光的方向向量和物体的法向量，但是它也决定于观察方向

$$
I_{diffuse} = k_d \cdot I_l \cdot \max(0, \mathbf{N} \cdot \mathbf{L})
$$

```c
// 镜面（Phong）
vec3 V = normalize(viewPos  - FragPos);
vec3 R = reflect(-L, N);
float specFactor = pow(max(dot(R, V), 0.0), shininess);
vec3 specular = specFactor * lightColor * specColor;
```

#### 基础颜色调制模拟光照(Ambient)

```c
FragColor = vec4(lightColor * objectColor, 1.0);
```
- 不是任何标准光照模型（比如 Lambert 漫反射、Phong、Blinn-Phong）
- 没有考虑光的位置、方向、法线、衰减等因素
- 物体的基色被光的颜色调制


#### VBO/VAO 的常规流程：生成 → 绑定 → 上传数据 → 设置属性 → 使用 → 解绑
##### VBO（顶点缓冲对象）操作流程
```c
// 生成缓冲对象
GLuint VBO;
glGenBuffers(1, &VBO);
// 绑定缓冲对象
glBindBuffer(GL_ARRAY_BUFFER, VBO);
// 上传数据到显存
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// 这两处的 0 表示你要描述 位置属性（通常在顶点着色器里写成 layout (location = 0) in vec3 aPos;）
```
##### VAO（顶点数组对象）操作流程
```c
// 生成 VAO
GLuint VAO;
glGenVertexArrays(1, &VAO);
// 绑定 VAO
glBindVertexArray(VAO);
// 绑定并配置 VBO
// 解绑 VAO
glBindVertexArray(0);
```
使用时
```c
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);
glBindVertexArray(0);
```

#### opengl加载obj的blender转换
导出obj时blender4.2需要勾选copy path导出，这样mtl中包含纹理信息

https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/
#### OpenGL到底是什么
包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范

- OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现的，
将由OpenGL库的开发者自行决定
- OpenGL的大多数实现都是由显卡厂商编写

早期的OpenGL使用立即渲染模式，效率太低，从OpenGL3.2开始，规范文档开始废弃立即渲染模式，鼓励开发者在OpenGL的核心模式

从OpenGL3.2开始，规范文档开始废弃立即渲染模式

##### 双缓冲(Double Buffer)
前缓冲保存着最终输出的图像，会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。
当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来glfwSwapBuffers(window);

#### 三角形
顶点数组对象：Vertex Array Object，VAO
顶点缓冲对象：Vertex Buffer Object，VBO
元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO

#### 图形渲染管线（Graphics Pipeline）
3D坐标转为2D坐标的处理过程由管线管理
实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。

###### 着色器(Shader)：
图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。
当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。
这个小程序就叫着色器

###### 图元(Primitive)：
为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要指定这些数据所表示的渲染类型。
我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？
做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。

###### 顶点缓冲对象(Vertex Buffer Objects, VBO)
顶点着色器会在GPU上创建内存用于储存顶点数据
通过VBO管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。
使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以要尝试尽量一次性发送尽可能多的数据
##### 绑定
OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。
glBindBuffer(GL_ARRAY_BUFFER, VBO);这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)
